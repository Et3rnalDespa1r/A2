# A2 — Экспериментальный анализ Merge Sort и Merge+Insertion Sort

В работе проведены замеры времени выполнения двух реализаций сортировки:

1. **Стандартный Merge Sort**
2. **Гибридный Merge+Insertion Sort** — при длине подпоследовательности ≤ *threshold* рекурсивное деление прекращается, и вызывается insertion sort.

Исследование выполнено на трёх типах входных данных:
- случайные массивы (**Random**),
- массивы, отсортированные в обратном порядке (**Reversed**),
- «почти отсортированные» массивы (**Almost**).

---

## Методика

### Генерация тестовых данных

Класс `ArrayGenerator` генерирует массивы целых чисел со следующими свойствами:

- **Random** — равномерно-случайные значения в диапазоне `[0; 6000]`;
- **Reversed** — массив сортируется по возрастанию и разворачивается;
- **Almost** — массив сортируется, после чего выполняется небольшое количество случайных обменов (получается почти отсортированная последовательность).

Размеры массивов: от **500** до **100000** с шагом **100**.  
Для стабильности эксперимента используется одна базовая выборка большой длины, из которой берутся префиксы нужного размера.

### Алгоритмы

- `merge_core` — классический рекурсивный merge sort с выделением дополнительного буфера.
- `merge_hybrid` — та же схема, но при длине подмассива ≤ *threshold* вызывается `insertion_sort`.

В задаче Codeforces используется порог:

```cpp
const int INSERTION_THRESHOLD = 15;
```
ID успешной посылки по задаче A2i: 349015973.

### Замеры времени

Замеры выполняются с помощью std::chrono::high_resolution_clock.
Для каждой тройки параметров

* тип массива (Random / Reversed / Almost),
* размер n,
* алгоритм (`merge` или hybrid с конкретным `threshold`)

выполняется несколько прогонов, после чего берётся среднее время в микросекундах.

Все результаты сохраняются в results_a2.csv:
```
тип_массива,размер,алгоритм,threshold,время_мкс
random,500,merge,0,1234
random,500,hybrid,5,900
```
---

## Структура проекта

* a2i.cpp — решение задачи A2i (гибридный алгоритм для Codeforces).
* a2.cpp — экспериментальный стенд: генерация массивов, многократные замеры, запись results_a2.csv.
* results_a2.csv — сырые экспериментальные данные.
* plots/plot.py — построение графиков.
* plots/random_times.png, plots/reversed_times.png, plots/almost_times.png —
  зависимость времени от размера массива для разных алгоритмов.
* plots/random_threshold.png, plots/reversed_threshold.png, plots/almost_threshold.png —
  влияние порога вставки на среднее время работы гибридного алгоритма.

---

## Запуск
```bash
# сборка и запуск экспериментов
g++ -std=gnu++17 -O2 a2.cpp -o a2
./a2          # создаёт results_a2.csv

# построение графиков
cd plots
python plot.py
```
---

# Сравнительный анализ

Анализ выполнен по данным из results_a2.csv и построенным графикам:

* random_times.png, reversed_times.png, almost_times.png — зависимость времени от размера массива;
* random_threshold.png, reversed_threshold.png, almost_threshold.png — влияние порога вставки.

---

## 1. Сравнение стандартного MERGE SORT и гибридного MERGE+INSERTION SORT

### Random массивы

По графику random_times.png видно:

* При небольших размерах (`n < 20 000`) гибридный алгоритм стабильно быстрее стандартного merge.
* В районе n = 30 000 – 50 000 разница уменьшается, но гибрид остаётся чуть быстрее.
* При больших размерах (`n > 70 000`) время merge и hybrid практически совпадает.

Причина: на случайных данных локально отсортированных участков нет, но overhead рекурсии merge уменьшается за счёт того, что небольшие подмассивы сортируются вставками.

Вывод: гибрид выигрывает, но умеренно.

---

### Reversed массивы

По графику reversed_times.png:

* На обратных массивах insertion sort работает хуже (близко к худшему случаю), поэтому выигрыш минимальный.
* Гибрид быстрее только на малых n (< 10 000).
* После ~40k разница становится небольшой, временами merge и hybrid идут почти одинаково.
Вывод: для полностью развёрнутых данных гибридный подход даёт небольшой плюс на малых n и почти не улучшает ситуацию на больших.

---

### Almost-sorted массивы

По графику almost_times.png:

* Гибридный алгоритм уверенно быстрее merge на всём диапазоне n.
* Максимальный разрыв — в области n = 5k…25k, до 30–40% ускорения.
* При росте n кривые сближаются, но hybrid остаётся значительно лучше.

Причина: insertion sort работает почти за линейное время на таких данных.

Вывод: гибридная схема наиболее эффективна на почти отсортированных входах.

---

## 2. Влияние порога вставки (threshold)

Анализ проводится на основе *_threshold.png.

### Общая тенденция

* При малых порогах (5–10) гибрид работает хуже, так как insertion sort применяется слишком редко.
* При порогах 15–30 достигается оптимум: overhead рекурсии уменьшается, а вставки всё ещё быстрые.
* При больших порогах (50+) время начинает расти, особенно на reversed.

### Random

* Минимальное время достигается примерно при threshold ≈ 20–30.
* После 40 время растёт.
* После 50 гибрид становится местами медленнее merge.

### Reversed

* Оптимум — 15–20.
* При threshold > 40 гибрид уверенно хуже стандартного merge.

### Almost

* Чем выше threshold, тем быстрее (до 50).
* В рассматриваемом диапазоне не наблюдается ухудшения.

---

## 3. Точка, начиная с которой гибрид медленнее merge

По графикам времени:

* Random: примерно при threshold ≥ 40.
* Reversed: примерно при threshold ≥ 30–40.
* Almost: гибрид всегда быстрее, ухудшения нет в видимом диапазоне.

То есть критическое пороговое значение — ≈ 35–40.

---

## 4. Общий вывод

1. Гибридный MERGE+INSERTION стабильно быстрее, особенно:

   * на almost-sorted;
   * на малых и средних n;
   * при разумном пороге (`15–30`).

2. Стандартный MERGE выигрывает только когда порог слишком большой (`threshold > 40`) или на полностью обратных массивах.

3. Оптимальный диапазон порога, подтверждённый экспериментами:
   15–30 элементов.

4. Порог 15, используемый в решении A2i (ID 349015973), попадает в оптимальную зону и является корректным выбором.
